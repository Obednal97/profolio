generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          String      @id @default(uuid())
  email       String      @unique
  taxCountry  String?
  taxRate     Int?
  createdAt   DateTime    @default(now())
  password    String
  updatedAt   DateTime    @default(now()) @updatedAt
  name        String?
  apiKeys     ApiKey[]
  assets      Asset[]
  expenses    Expense[]
  liabilities Liability[]
  properties  Property[]
  settings    Settings?
}

model Asset {
  id               String             @id @default(uuid())
  userId           String
  name             String
  quantity         Decimal            @default(0) @db.Decimal(18, 8)
  source           String?
  externalId       String?
  current_value    Int?
  valueOverride    Int?
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @default(now()) @updatedAt
  type             AssetType
  currency         String?
  symbol           String?
  autoSync         Boolean            @default(false)
  initialAmount    Int?
  interestRate     Int?
  interestType     InterestType?
  lastSyncedAt     DateTime?
  maturityDate     DateTime?
  paymentFrequency PaymentFrequency?
  purchaseDate     DateTime?
  purchasePrice    Int?
  termLength       Int?
  user             User               @relation(fields: [userId], references: [id])
  transactions     AssetTransaction[]
  priceHistory     PriceHistory[]
  
  notes            String?
  vesting_start_date DateTime?
  vesting_end_date   DateTime?
  vesting_schedule   Json?
  
  symbolData       Symbol?            @relation("SymbolAssets", fields: [symbol], references: [symbol])
  
  @@index([userId, type])
  @@index([symbol, type])
  @@index([userId, symbol])
  @@index([lastSyncedAt])
}

model PriceHistory {
  id        String   @id @default(uuid())
  assetId   String
  symbol    String
  price     Int
  timestamp DateTime
  source    String
  asset     Asset    @relation(fields: [assetId], references: [id], onDelete: Cascade)
  
  symbolData Symbol? @relation("SymbolPriceHistory", fields: [symbol], references: [symbol])

  @@unique([assetId, timestamp, source])
  @@index([assetId, timestamp])
  @@index([symbol, timestamp])
  @@index([timestamp])
  @@index([symbol, timestamp, source])
  @@index([assetId, timestamp, price])
}

model AssetTransaction {
  id          String   @id @default(uuid())
  assetId     String
  type        String
  quantity    Int
  price       Int
  fees        Int?
  totalValue  Int
  date        DateTime
  description String?
  asset       Asset    @relation(fields: [assetId], references: [id], onDelete: Cascade)

  @@index([assetId, date])
  @@index([assetId, type, date])
  @@index([date])
}

model ApiKey {
  id                           String      @id @default(cuid())
  userId                       String
  provider                     ApiProvider
  isActive                     Boolean     @default(true)
  createdAt                    DateTime    @default(now())
  updatedAt                    DateTime    @updatedAt
  expiresAt                    DateTime?
  permissions                  String[]    @default([])
  rateLimitInfo                Json?
  testResult                   String?
  testedAt                     DateTime?
  user_api_key_display_name    String
  user_api_key_encrypted_value String
  user_api_key_environment     String      @default("production")
  user                         User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, provider, user_api_key_display_name])
  @@index([userId, provider, isActive])
  @@index([provider, isActive])
  @@map("ApiKey")
}

model MarketDataJob {
  id         String      @id @default(uuid())
  symbol     String
  provider   ApiProvider
  lastRun    DateTime?
  nextRun    DateTime
  isActive   Boolean     @default(true)
  errorCount Int         @default(0)
  lastError  String?
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @default(now()) @updatedAt

  @@unique([symbol, provider])
  @@index([nextRun, isActive])
  @@index([provider, isActive])
}

model Liability {
  id           String    @id @default(uuid())
  userId       String
  name         String
  balance      Int
  interestRate Int
  dueDate      DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @default(now()) @updatedAt
  user         User      @relation(fields: [userId], references: [id])
  
  @@index([userId])
  @@index([dueDate])
}

model Expense {
  id        String   @id @default(uuid())
  amount    Int      // Amount in cents for consistency
  category  String
  date      DateTime
  notes     String?
  userId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
  user      User     @relation(fields: [userId], references: [id])
  
  @@index([userId, date])
  @@index([userId, category])
  @@index([date])
}

model Settings {
  userId    String   @id
  theme     String?
  currency  String?
  timezone  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
  user      User     @relation(fields: [userId], references: [id])
}

model Property {
  id           String   @id @default(uuid())
  address      String
  value        Int
  purchaseDate DateTime
  notes        String?
  userId       String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @default(now()) @updatedAt
  user         User     @relation(fields: [userId], references: [id])
  
  @@index([userId])
  @@index([purchaseDate])
}

model Symbol {
  id            String      @id @default(uuid())
  symbol        String      @unique
  name          String
  type          AssetType   // STOCK, CRYPTO, etc.
  exchange      String?     // NYSE, NASDAQ, etc.
  sector        String?     // Technology, Healthcare, etc.
  industry      String?     // Software, Pharmaceuticals, etc.
  market_cap    BigInt?     // Market cap in cents
  
  // Price data
  current_price Int?        // Current price in cents
  previous_close Int?       // Previous close in cents
  day_change    Int?        // Day change in cents
  day_change_percent Decimal? @db.Decimal(10, 4) // Day change percentage
  volume        BigInt?     // Trading volume
  avg_volume    BigInt?     // Average volume
  
  // Metadata
  last_updated  DateTime?   // When price was last updated
  added_at      DateTime    @default(now())
  is_active     Boolean     @default(true)
  update_priority Int       @default(1) // 1=high, 2=medium, 3=low
  
  // Error tracking
  error_count   Int         @default(0)
  last_error    String?
  last_error_at DateTime?
  
  // Relationships
  assets        Asset[]     @relation("SymbolAssets")
  priceHistory  PriceHistory[] @relation("SymbolPriceHistory")
  
  @@index([symbol, is_active])
  @@index([type, is_active])
  @@index([last_updated, update_priority])
  @@index([update_priority, is_active])
}

enum AssetType {
  CRYPTO
  STOCK
  PROPERTY
  EQUITY
  OTHER
  BOND
  SAVINGS
}

enum InterestType {
  SIMPLE
  COMPOUND
}

enum PaymentFrequency {
  MONTHLY
  QUARTERLY
  ANNUALLY
}

enum ApiProvider {
  ALPHA_VANTAGE
  TWELVE_DATA
  POLYGON_IO
  COINGECKO
  COINMARKETCAP
  BINANCE
  TRADING212
}

// Queue for processing new symbols that don't exist in our database
model SymbolQueue {
  id            String      @id @default(uuid())
  symbol        String      @unique
  requested_by  String?     // User ID who requested it
  asset_type    AssetType?  // Guessed type
  priority      Int         @default(2) // 1=urgent, 2=normal, 3=low
  status        String      @default("PENDING") // PENDING, PROCESSING, COMPLETED, FAILED
  attempts      Int         @default(0)
  last_attempt  DateTime?
  error_message String?
  created_at    DateTime    @default(now())
  processed_at  DateTime?
  
  @@index([status, priority])
  @@index([created_at])
}
